import { Command, Flags } from '@oclif/core';
import chalk from 'chalk';
import fs from 'fs/promises';
import path from 'path';

export default class HooksInstall extends Command {
    static override description = 'Install and configure Git hooks';

    static override examples = [
        '<%= config.bin %> <%= command.id %> --hooks pre-commit,commit-msg',
        '<%= config.bin %> <%= command.id %> --hooks pre-push --force',
    ];

    static override flags = {
        hooks: Flags.string({
            description: 'Comma-separated list of hooks to install',
            required: true,
        }),
        force: Flags.boolean({
            description: 'Force installation, overwriting existing hooks',
            default: false,
        }),
        config: Flags.string({
            description: 'Hook configuration in JSON format',
        }),
        options: Flags.string({
            description: 'Comma-separated list of hook options',
        }),
        output: Flags.string({
            description: 'Output directory for hook scripts',
            default: '.git/hooks',
        }),
    };

    async run(): Promise<void> {
        const { flags } = await this.parse(HooksInstall);

        try {
            await this.installHooks(flags);
            this.log(chalk.green('‚úÖ Hooks installed successfully'));
        } catch (error) {
            this.error(`Failed to install hooks: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async installHooks(flags: any): Promise<void> {
        const { hooks, force, config, options, output } = flags;

        this.log(chalk.blue('‚öôÔ∏è Installing Git Hooks'));
        this.log('='.repeat(50));

        const hookList = hooks.split(',').map(h => h.trim());
        const hookOptions = options ? options.split(',').map(o => o.trim()) : [];
        const hookConfig = config ? JSON.parse(config) : {};

        this.log(chalk.yellow(`Hooks to install: ${hookList.join(', ')}`));
        if (hookOptions.length > 0) {
            this.log(chalk.yellow(`Options: ${hookOptions.join(', ')}`));
        }

        // Ensure output directory exists
        await fs.mkdir(output, { recursive: true });

        for (const hookName of hookList) {
            await this.installHook(hookName, force, hookConfig[hookName], hookOptions, output);
        }
    }

    private async installHook(hookName: string, force: boolean, config: any, options: string[], output: string): Promise<void> {
        this.log(chalk.blue(`\nüì¶ Installing ${hookName} hook`));

        const hookPath = path.join(output, hookName);

        // Check if hook already exists
        try {
            await fs.access(hookPath);
            if (!force) {
                this.log(chalk.yellow(`‚ö†Ô∏è  Hook ${hookName} already exists. Use --force to overwrite.`));
                return;
            } else {
                this.log(chalk.yellow(`üîÑ Overwriting existing ${hookName} hook`));
            }
        } catch {
            // Hook doesn't exist, proceed with installation
        }

        try {
            const hookContent = await this.generateHookContent(hookName, config, options);
            await fs.writeFile(hookPath, hookContent, { mode: 0o755 });
            this.log(chalk.green(`‚úÖ ${hookName} hook installed successfully`));
        } catch (error) {
            this.log(chalk.red(`‚ùå Failed to install ${hookName} hook`));
            throw error;
        }
    }

    private async generateHookContent(hookName: string, config: any, options: string[]): Promise<string> {
        const baseContent = `#!/bin/sh
# Git hook: ${hookName}
# Generated by pothos-todo CLI
# ${new Date().toISOString()}

set -e

# Hook configuration
HOOK_NAME="${hookName}"
HOOK_CONFIG='${JSON.stringify(config || {})}'
HOOK_OPTIONS='${JSON.stringify(options)}'

# Log hook execution
echo "Executing ${hookName} hook..."

`;

        switch (hookName) {
            case 'pre-commit':
                return this.generatePreCommitHook(baseContent, config, options);
            case 'commit-msg':
                return this.generateCommitMsgHook(baseContent, config, options);
            case 'pre-push':
                return this.generatePrePushHook(baseContent, config, options);
            case 'post-commit':
                return this.generatePostCommitHook(baseContent, config, options);
            case 'pre-receive':
                return this.generatePreReceiveHook(baseContent, config, options);
            case 'post-receive':
                return this.generatePostReceiveHook(baseContent, config, options);
            case 'update':
                return this.generateUpdateHook(baseContent, config, options);
            case 'applypatch-msg':
                return this.generateApplypatchMsgHook(baseContent, config, options);
            case 'pre-applypatch':
                return this.generatePreApplypatchHook(baseContent, config, options);
            case 'post-applypatch':
                return this.generatePostApplypatchHook(baseContent, config, options);
            case 'pre-rebase':
                return this.generatePreRebaseHook(baseContent, config, options);
            case 'post-rewrite':
                return this.generatePostRewriteHook(baseContent, config, options);
            case 'pre-merge-commit':
                return this.generatePreMergeCommitHook(baseContent, config, options);
            case 'prepare-commit-msg':
                return this.generatePrepareCommitMsgHook(baseContent, config, options);
            case 'commit-msg':
                return this.generateCommitMsgHook(baseContent, config, options);
            case 'post-commit':
                return this.generatePostCommitHook(baseContent, config, options);
            case 'pre-rebase':
                return this.generatePreRebaseHook(baseContent, config, options);
            case 'post-checkout':
                return this.generatePostCheckoutHook(baseContent, config, options);
            case 'post-merge':
                return this.generatePostMergeHook(baseContent, config, options);
            case 'pre-auto-gc':
                return this.generatePreAutoGcHook(baseContent, config, options);
            case 'post-update':
                return this.generatePostUpdateHook(baseContent, config, options);
            case 'push-to-checkout':
                return this.generatePushToCheckoutHook(baseContent, config, options);
            case 'pre-push':
                return this.generatePrePushHook(baseContent, config, options);
            case 'post-index-change':
                return this.generatePostIndexChangeHook(baseContent, config, options);
            default:
                return this.generateGenericHook(baseContent, hookName, config, options);
        }
    }

    private generatePreCommitHook(baseContent: string, config: any, options: string[]): string {
        const checks = config?.checks || ['lint', 'test', 'type-check'];
        const skipChecks = config?.skipChecks || [];

        return `${baseContent}
# Pre-commit hook configuration
CHECKS="${checks.join(' ')}"
SKIP_CHECKS="${skipChecks.join(' ')}"

echo "Running pre-commit checks..."

# Linting
if [[ " $CHECKS " =~ " lint " ]] && [[ ! " $SKIP_CHECKS " =~ " lint " ]]; then
  echo "Running linting..."
  if ! npm run lint; then
    echo "‚ùå Linting failed"
    exit 1
  fi
fi

# Type checking
if [[ " $CHECKS " =~ " type-check " ]] && [[ ! " $SKIP_CHECKS " =~ " type-check " ]]; then
  echo "Running type checking..."
  if ! npm run type-check; then
    echo "‚ùå Type checking failed"
    exit 1
  fi
fi

# Tests
if [[ " $CHECKS " =~ " test " ]] && [[ ! " $SKIP_CHECKS " =~ " test " ]]; then
  echo "Running tests..."
  if ! npm test; then
    echo "‚ùå Tests failed"
    exit 1
  fi
fi

# Build check
if [[ " $CHECKS " =~ " build " ]] && [[ ! " $SKIP_CHECKS " =~ " build " ]]; then
  echo "Running build check..."
  if ! npm run build; then
    echo "‚ùå Build failed"
    exit 1
  fi
fi

echo "‚úÖ Pre-commit checks passed"
`;
    }

    private generateCommitMsgHook(baseContent: string, config: any, options: string[]): string {
        const patterns = config?.patterns || ['^(feat|fix|docs|style|refactor|test|chore)(\\(.+\\))?: .+'];
        const maxLength = config?.maxLength || 72;

        return `${baseContent}
# Commit message hook configuration
PATTERNS="${patterns.join('|')}"
MAX_LENGTH=${maxLength}

COMMIT_MSG_FILE="\$1"
COMMIT_MSG=\$(cat "\$COMMIT_MSG_FILE")

echo "Validating commit message..."

# Check length
if [ \${#COMMIT_MSG} -gt $MAX_LENGTH ]; then
  echo "‚ùå Commit message too long (max $MAX_LENGTH characters)"
  echo "Message: \$COMMIT_MSG"
  exit 1
fi

# Check pattern
if ! echo "\$COMMIT_MSG" | grep -E "^$PATTERNS$" > /dev/null; then
  echo "‚ùå Commit message doesn't match pattern"
  echo "Expected pattern: $patterns"
  echo "Message: \$COMMIT_MSG"
  exit 1
fi

echo "‚úÖ Commit message validation passed"
`;
    }

    private generatePrePushHook(baseContent: string, config: any, options: string[]): string {
        const checks = config?.checks || ['test', 'build'];

        return `${baseContent}
# Pre-push hook configuration
CHECKS="${checks.join(' ')}"

echo "Running pre-push checks..."

# Run tests
if [[ " $CHECKS " =~ " test " ]]; then
  echo "Running tests..."
  if ! npm test; then
    echo "‚ùå Tests failed"
    exit 1
  fi
fi

# Build check
if [[ " $CHECKS " =~ " build " ]]; then
  echo "Running build check..."
  if ! npm run build; then
    echo "‚ùå Build failed"
    exit 1
  fi
fi

# Security scan
if [[ " $CHECKS " =~ " security " ]]; then
  echo "Running security scan..."
  if ! npm audit; then
    echo "‚ùå Security scan failed"
    exit 1
  fi
fi

echo "‚úÖ Pre-push checks passed"
`;
    }

    private generatePostCommitHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Post-commit hook configuration

echo "Running post-commit tasks..."

# Update version if needed
if [[ " $options " =~ " version " ]]; then
  echo "Updating version..."
  npm version patch --no-git-tag-version
fi

# Notify team
if [[ " $options " =~ " notify " ]]; then
  echo "Sending notifications..."
  # TODO: Implement notification logic
fi

echo "‚úÖ Post-commit tasks completed"
`;
    }

    private generatePreReceiveHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Pre-receive hook configuration

echo "Running pre-receive checks..."

# TODO: Implement pre-receive logic
echo "‚úÖ Pre-receive checks passed"
`;
    }

    private generatePostReceiveHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Post-receive hook configuration

echo "Running post-receive tasks..."

# TODO: Implement post-receive logic
echo "‚úÖ Post-receive tasks completed"
`;
    }

    private generateUpdateHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Update hook configuration

echo "Running update checks..."

# TODO: Implement update logic
echo "‚úÖ Update checks passed"
`;
    }

    private generateApplypatchMsgHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Applypatch-msg hook configuration

echo "Validating patch message..."

# TODO: Implement applypatch-msg logic
echo "‚úÖ Patch message validation passed"
`;
    }

    private generatePreApplypatchHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Pre-applypatch hook configuration

echo "Running pre-applypatch checks..."

# TODO: Implement pre-applypatch logic
echo "‚úÖ Pre-applypatch checks passed"
`;
    }

    private generatePostApplypatchHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Post-applypatch hook configuration

echo "Running post-applypatch tasks..."

# TODO: Implement post-applypatch logic
echo "‚úÖ Post-applypatch tasks completed"
`;
    }

    private generatePreRebaseHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Pre-rebase hook configuration

echo "Running pre-rebase checks..."

# TODO: Implement pre-rebase logic
echo "‚úÖ Pre-rebase checks passed"
`;
    }

    private generatePostRewriteHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Post-rewrite hook configuration

echo "Running post-rewrite tasks..."

# TODO: Implement post-rewrite logic
echo "‚úÖ Post-rewrite tasks completed"
`;
    }

    private generatePreMergeCommitHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Pre-merge-commit hook configuration

echo "Running pre-merge-commit checks..."

# TODO: Implement pre-merge-commit logic
echo "‚úÖ Pre-merge-commit checks passed"
`;
    }

    private generatePrepareCommitMsgHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Prepare-commit-msg hook configuration

echo "Preparing commit message..."

# TODO: Implement prepare-commit-msg logic
echo "‚úÖ Commit message prepared"
`;
    }

    private generatePostCheckoutHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Post-checkout hook configuration

echo "Running post-checkout tasks..."

# Install dependencies
if [[ " $options " =~ " install " ]]; then
  echo "Installing dependencies..."
  npm install
fi

# Setup environment
if [[ " $options " =~ " setup " ]]; then
  echo "Setting up environment..."
  # TODO: Implement environment setup
fi

echo "‚úÖ Post-checkout tasks completed"
`;
    }

    private generatePostMergeHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Post-merge hook configuration

echo "Running post-merge tasks..."

# Install dependencies
if [[ " $options " =~ " install " ]]; then
  echo "Installing dependencies..."
  npm install
fi

echo "‚úÖ Post-merge tasks completed"
`;
    }

    private generatePreAutoGcHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Pre-auto-gc hook configuration

echo "Running pre-auto-gc checks..."

# TODO: Implement pre-auto-gc logic
echo "‚úÖ Pre-auto-gc checks passed"
`;
    }

    private generatePostUpdateHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Post-update hook configuration

echo "Running post-update tasks..."

# TODO: Implement post-update logic
echo "‚úÖ Post-update tasks completed"
`;
    }

    private generatePushToCheckoutHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Push-to-checkout hook configuration

echo "Running push-to-checkout checks..."

# TODO: Implement push-to-checkout logic
echo "‚úÖ Push-to-checkout checks passed"
`;
    }

    private generatePostIndexChangeHook(baseContent: string, config: any, options: string[]): string {
        return `${baseContent}
# Post-index-change hook configuration

echo "Running post-index-change tasks..."

# TODO: Implement post-index-change logic
echo "‚úÖ Post-index-change tasks completed"
`;
    }

    private generateGenericHook(baseContent: string, hookName: string, config: any, options: string[]): string {
        return `${baseContent}
# Generic ${hookName} hook configuration

echo "Running ${hookName} hook..."

# TODO: Implement ${hookName} logic
echo "‚úÖ ${hookName} hook completed"
`;
    }
} 