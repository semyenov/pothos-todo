/**
 * Comprehensive Orchestration Demo
 * 
 * This example demonstrates the complete Advanced Service Integration & Orchestration system
 * with all enterprise features including:
 * - Dependency-aware startup with health gates
 * - Type-safe service communication with circuit breakers
 * - Performance profiling and optimization
 * - Real-time monitoring and health checks
 * - Chaos engineering and resilience testing
 * - Rolling restarts and zero-downtime updates
 */

import { logger } from '@/lib/unjs-utils.js';
import { EnhancedSystemIntegration } from '@/infrastructure/orchestration/SystemIntegration.enhanced.js';
import { EnhancedServiceRegistry } from '@/infrastructure/core/ServiceRegistry.enhanced.js';
import { ServiceCommunicationHub } from '@/infrastructure/orchestration/ServiceCommunicationHub.js';
import { StartupOrchestrator, DEFAULT_STARTUP_STAGES } from '@/infrastructure/core/StartupOrchestrator.js';
import { ServiceHealthMonitor } from '@/infrastructure/core/ServiceHealthMonitor.js';
import { ServiceMetrics } from '@/infrastructure/core/ServiceMetrics.js';
import { ServiceTracing } from '@/infrastructure/core/ServiceTracing.js';

/**
 * Main orchestration demo
 */
async function runOrchestrationDemo(): Promise<void> {
  logger.info('üöÄ Starting Advanced Service Orchestration Demo...');\n\n  try {\n    // Get singleton instances\n    const systemIntegration = EnhancedSystemIntegration.getInstance();\n    const registry = EnhancedServiceRegistry.getInstance();\n    const communicationHub = ServiceCommunicationHub.getInstance();\n    const healthMonitor = ServiceHealthMonitor.getInstance();\n    const metrics = ServiceMetrics.getInstance();\n    const tracing = ServiceTracing.getInstance();\n\n    // Set up event listeners for demo\n    setupDemoEventListeners(systemIntegration, registry, healthMonitor);\n\n    // === PHASE 1: ORCHESTRATED STARTUP ===\n    logger.info('\\nüìã PHASE 1: Demonstrating Orchestrated Startup...');\n    \n    console.time('orchestrated-startup');\n    await systemIntegration.initialize({\n      strategy: 'orchestrated',\n      parallel: true,\n      skipOptional: false,\n      enableProfiling: true,\n      enableChaos: false, // Disable for initial demo\n    });\n    console.timeEnd('orchestrated-startup');\n\n    // Show startup results\n    const status = await systemIntegration.getSystemStatus();\n    displayStartupResults(status);\n\n    // === PHASE 2: SERVICE COMMUNICATION ===\n    logger.info('\\nüì° PHASE 2: Demonstrating Service Communication...');\n    await demonstrateServiceCommunication(communicationHub, registry);\n\n    // === PHASE 3: HEALTH MONITORING ===\n    logger.info('\\nüîç PHASE 3: Demonstrating Health Monitoring...');\n    await demonstrateHealthMonitoring(systemIntegration, healthMonitor);\n\n    // === PHASE 4: PERFORMANCE PROFILING ===\n    logger.info('\\nüìä PHASE 4: Demonstrating Performance Profiling...');\n    await demonstratePerformanceProfiling(systemIntegration, metrics);\n\n    // === PHASE 5: CHAOS ENGINEERING ===\n    logger.info('\\nüî• PHASE 5: Demonstrating Chaos Engineering...');\n    await demonstrateChaosEngineering(systemIntegration, registry);\n\n    // === PHASE 6: OPTIMIZATION ===\n    logger.info('\\nüîß PHASE 6: Demonstrating Optimization...');\n    await demonstrateOptimization(systemIntegration);\n\n    // === PHASE 7: ROLLING RESTART ===\n    logger.info('\\n‚ôªÔ∏è PHASE 7: Demonstrating Rolling Restart...');\n    await demonstrateRollingRestart(systemIntegration);\n\n    // === PHASE 8: DISTRIBUTED TRACING ===\n    logger.info('\\nüîç PHASE 8: Demonstrating Distributed Tracing...');\n    await demonstrateDistributedTracing(tracing, communicationHub);\n\n    logger.info('\\nüéâ Orchestration Demo Completed Successfully!');\n    displayFinalSummary(systemIntegration);\n\n  } catch (error) {\n    logger.error('‚ùå Orchestration Demo Failed', { error });\n    throw error;\n  }\n}\n\n/**\n * Set up event listeners for demo visualization\n */\nfunction setupDemoEventListeners(\n  systemIntegration: EnhancedSystemIntegration,\n  registry: EnhancedServiceRegistry,\n  healthMonitor: ServiceHealthMonitor\n): void {\n  // System events\n  systemIntegration.on('system:startup-completed', ({ duration, strategy, profile }) => {\n    logger.info(`‚úÖ System startup completed using ${strategy} strategy`, {\n      duration: `${duration}ms`,\n      parallelEfficiency: `${profile.parallelEfficiency.toFixed(1)}%`,\n      bottlenecks: profile.bottlenecks.length,\n    });\n  });\n\n  systemIntegration.on('system:optimization-applied', ({ improvements, expectedGain }) => {\n    logger.info(`üîß Optimizations applied`, {\n      improvements: improvements.length,\n      expectedGain: `${expectedGain.toFixed(1)}%`,\n    });\n  });\n\n  // Registry events\n  registry.on('service:health-changed', ({ name, from, to }) => {\n    const emoji = to === 'healthy' ? '‚úÖ' : to === 'degraded' ? '‚ö†Ô∏è' : '‚ùå';\n    logger.info(`${emoji} Service health changed: ${name} (${from} ‚Üí ${to})`);\n  });\n\n  registry.on('dependencies:satisfied', ({ name, dependencies }) => {\n    logger.info(`üîó Dependencies satisfied for ${name}`, { dependencies });\n  });\n\n  // Health monitor events\n  healthMonitor.on('incident:created', ({ incident }) => {\n    logger.warn(`üö® Health incident: ${incident.serviceName}`, {\n      status: incident.status,\n    });\n  });\n\n  healthMonitor.on('incident:resolved', ({ incident, duration }) => {\n    logger.info(`‚úÖ Health incident resolved: ${incident.serviceName}`, {\n      duration: `${duration}ms`,\n    });\n  });\n}\n\n/**\n * Display startup results\n */\nfunction displayStartupResults(status: any): void {\n  logger.info('\\nüìä Startup Results:');\n  logger.info(`  ‚Ä¢ Total Services: ${status.services.length}`);\n  logger.info(`  ‚Ä¢ Healthy Services: ${status.health.summary.healthy}/${status.health.summary.total}`);\n  logger.info(`  ‚Ä¢ Startup Duration: ${status.performance.lastStartupDuration}ms`);\n  logger.info(`  ‚Ä¢ Parallel Efficiency: ${status.performance.parallelEfficiency.toFixed(1)}%`);\n  logger.info(`  ‚Ä¢ Critical Path: ${status.dependencies.criticalPath.totalTime}ms`);\n  \n  if (status.dependencies.circularDependencies.length > 0) {\n    logger.warn(`  ‚Ä¢ Circular Dependencies: ${status.dependencies.circularDependencies.length}`);\n  } else {\n    logger.info('  ‚Ä¢ No circular dependencies detected ‚úÖ');\n  }\n}\n\n/**\n * Demonstrate service communication features\n */\nasync function demonstrateServiceCommunication(\n  communicationHub: ServiceCommunicationHub,\n  registry: EnhancedServiceRegistry\n): Promise<void> {\n  logger.info('üîß Setting up communication demo...');\n\n  // Configure circuit breakers\n  communicationHub.configureCircuitBreaker('cache-manager', {\n    failureThreshold: 3,\n    timeout: 30000,\n    halfOpenRetryTimeout: 15000,\n  });\n\n  // Configure load balancer for caching capability\n  communicationHub.configureLoadBalancer('caching', {\n    strategy: 'least-connections',\n    healthCheck: true,\n  });\n\n  try {\n    // Demonstrate type-safe RPC call\n    logger.info('üìû Making type-safe RPC call...');\n    const cacheResult = await communicationHub.call(\n      'cache-manager',\n      'get',\n      { key: 'demo-key' },\n      { timeout: 5000, priority: 'normal' }\n    );\n    \n    logger.info('üìû RPC call completed', { result: cacheResult });\n\n    // Demonstrate capability-based call with load balancing\n    logger.info('‚öñÔ∏è Making capability-based call with load balancing...');\n    try {\n      const result = await communicationHub.callByCapability(\n        'caching',\n        'set',\n        { key: 'demo-key', value: 'demo-value', ttl: 3600 },\n        { timeout: 5000 }\n      );\n      logger.info('‚öñÔ∏è Load-balanced call completed', { result });\n    } catch (error) {\n      logger.info('‚öñÔ∏è Load-balanced call failed (expected for demo)', { \n        error: (error as Error).message \n      });\n    }\n\n    // Demonstrate event broadcasting\n    logger.info('üì° Broadcasting event to all services...');\n    await communicationHub.broadcastEvent(\n      'monitoring',\n      'demo:event',\n      { message: 'Hello from orchestration demo!', timestamp: new Date() }\n    );\n\n  } catch (error) {\n    logger.info('üìû Communication demo completed with expected errors', {\n      error: (error as Error).message,\n    });\n  }\n\n  // Show circuit breaker status\n  const circuitStatus = communicationHub.getCircuitBreakerStatus('cache-manager');\n  logger.info('üîå Circuit breaker status:', circuitStatus);\n\n  // Show communication statistics\n  const commStats = communicationHub.getStatistics();\n  logger.info('üìä Communication statistics:', commStats);\n}\n\n/**\n * Demonstrate health monitoring\n */\nasync function demonstrateHealthMonitoring(\n  systemIntegration: EnhancedSystemIntegration,\n  healthMonitor: ServiceHealthMonitor\n): Promise<void> {\n  logger.info('üîç Starting health monitoring demo...');\n\n  // Perform comprehensive health check\n  await systemIntegration.performHealthCheck();\n\n  // Get current incidents (should be none for healthy system)\n  const incidents = healthMonitor.getCurrentIncidents();\n  logger.info(`üìã Current incidents: ${incidents.length}`);\n\n  // Get health trends for a service\n  const trends = healthMonitor.getHealthTrends('cache-manager', 'hour');\n  if (trends) {\n    logger.info('üìà Health trends for cache-manager:', {\n      availability: `${trends.availability.toFixed(1)}%`,\n      incidents: trends.incidents,\n      mttr: `${trends.mttr}ms`,\n    });\n  }\n\n  // Generate health report\n  const healthReport = healthMonitor.generateHealthReport();\n  logger.info('üìÑ Health report summary:', {\n    total: healthReport.summary.totalServices,\n    healthy: healthReport.summary.healthyServices,\n    degraded: healthReport.summary.degradedServices,\n    unhealthy: healthReport.summary.unhealthyServices,\n    incidents: healthReport.summary.currentIncidents,\n  });\n\n  // Demonstrate predictive analysis\n  const predictions = healthMonitor.predictIssues('cache-manager');\n  if (predictions) {\n    logger.info('üîÆ Health predictions for cache-manager:', {\n      predictions: predictions.predictions.length,\n    });\n  }\n}\n\n/**\n * Demonstrate performance profiling\n */\nasync function demonstratePerformanceProfiling(\n  systemIntegration: EnhancedSystemIntegration,\n  metrics: ServiceMetrics\n): Promise<void> {\n  logger.info('üìä Starting performance profiling demo...');\n\n  // Record some sample metrics\n  metrics.record('demo-service', 'request_duration_ms', 150, 'histogram');\n  metrics.record('demo-service', 'requests_total', 1, 'counter');\n  metrics.record('demo-service', 'memory_usage_bytes', 128 * 1024 * 1024, 'gauge');\n\n  // Get service metrics\n  const serviceMetrics = metrics.getServiceMetrics('demo-service');\n  logger.info(`üìà Recorded ${serviceMetrics.length} metrics for demo-service`);\n\n  // Get aggregations\n  const aggregation = metrics.getAggregation('demo-service', 'request_duration_ms');\n  if (aggregation) {\n    logger.info('üìä Request duration aggregation:', {\n      avg: `${aggregation.avg.toFixed(2)}ms`,\n      p95: `${aggregation.p95}ms`,\n      p99: `${aggregation.p99}ms`,\n    });\n  }\n\n  // Get all services summary\n  const summary = metrics.getAllServicesSummary();\n  logger.info(`üìä Metrics summary: ${summary.size} services with metrics`);\n\n  // Export Prometheus metrics\n  const prometheusMetrics = metrics.exportPrometheus();\n  logger.info(`üìä Prometheus export: ${prometheusMetrics.split('\\n').length} lines`);\n\n  // Analyze performance\n  const performance = metrics.analyzeServicePerformance('demo-service');\n  if (performance) {\n    logger.info('üîç Performance analysis:', {\n      avgResponseTime: `${performance.responseTime.avg.toFixed(2)}ms`,\n      errorRate: `${performance.errorRate.toFixed(2)}%`,\n      throughput: `${performance.throughput.toFixed(2)} req/min`,\n      availability: `${performance.availability.toFixed(2)}%`,\n    });\n  }\n}\n\n/**\n * Demonstrate chaos engineering\n */\nasync function demonstrateChaosEngineering(\n  systemIntegration: EnhancedSystemIntegration,\n  registry: EnhancedServiceRegistry\n): Promise<void> {\n  logger.info('üî• Starting chaos engineering demo...');\n\n  const chaosService = registry.get('chaos-engineering');\n  if (chaosService) {\n    try {\n      // Create a mild chaos experiment\n      const experiment = {\n        name: 'demo-latency-injection',\n        type: 'latency',\n        config: {\n          minDelay: 50,\n          maxDelay: 200,\n          probability: 0.1,\n          duration: 30000, // 30 seconds\n        },\n      };\n\n      await chaosService.createExperiment(experiment);\n      logger.info('üß™ Created chaos experiment:', experiment.name);\n\n      // Run the experiment for a short time\n      await chaosService.startExperiment(experiment.name);\n      logger.info('üî• Chaos experiment started');\n\n      // Wait a bit to let it run\n      await new Promise(resolve => setTimeout(resolve, 5000));\n\n      // Stop the experiment\n      await chaosService.stopExperiment(experiment.name);\n      logger.info('‚èπÔ∏è Chaos experiment stopped');\n\n      // Get experiment results\n      const results = await chaosService.getExperimentResults(experiment.name);\n      logger.info('üìä Chaos experiment results:', {\n        duration: results.duration,\n        affectedServices: results.affectedServices?.length || 0,\n        events: results.events?.length || 0,\n      });\n\n    } catch (error) {\n      logger.info('üî• Chaos engineering demo completed', {\n        note: 'Some chaos operations may not be fully implemented in demo mode',\n      });\n    }\n  } else {\n    logger.info('üî• Chaos engineering service not available for demo');\n  }\n}\n\n/**\n * Demonstrate optimization\n */\nasync function demonstrateOptimization(\n  systemIntegration: EnhancedSystemIntegration\n): Promise<void> {\n  logger.info('üîß Starting optimization demo...');\n\n  // Apply optimizations based on current profiling data\n  await systemIntegration.applyOptimizations();\n\n  // Get updated system status\n  const status = await systemIntegration.getSystemStatus();\n  logger.info('üìä Post-optimization status:', {\n    averageStartupTime: `${status.performance.averageStartupTime}ms`,\n    parallelEfficiency: `${status.performance.parallelEfficiency.toFixed(1)}%`,\n    profiles: status.performance.startupProfiles,\n  });\n}\n\n/**\n * Demonstrate rolling restart\n */\nasync function demonstrateRollingRestart(\n  systemIntegration: EnhancedSystemIntegration\n): Promise<void> {\n  logger.info('‚ôªÔ∏è Starting rolling restart demo...');\n\n  try {\n    // Restart the system with optimization\n    console.time('rolling-restart');\n    await systemIntegration.restart('demo-restart', {\n      strategy: 'orchestrated',\n      optimizeBeforeRestart: true,\n    });\n    console.timeEnd('rolling-restart');\n\n    logger.info('‚úÖ Rolling restart completed successfully');\n\n    // Show improved performance\n    const status = await systemIntegration.getSystemStatus();\n    logger.info('üìä Post-restart performance:', {\n      lastStartup: `${status.performance.lastStartupDuration}ms`,\n      averageStartup: `${status.performance.averageStartupTime}ms`,\n      efficiency: `${status.performance.parallelEfficiency.toFixed(1)}%`,\n    });\n\n  } catch (error) {\n    logger.error('‚ôªÔ∏è Rolling restart demo failed', { error });\n  }\n}\n\n/**\n * Demonstrate distributed tracing\n */\nasync function demonstrateDistributedTracing(\n  tracing: ServiceTracing,\n  communicationHub: ServiceCommunicationHub\n): Promise<void> {\n  logger.info('üîç Starting distributed tracing demo...');\n\n  // Start a trace\n  const trace = tracing.startTrace('demo-service', 'complex-operation', {\n    userId: 'demo-user',\n    operation: 'demo',\n  });\n\n  if (trace) {\n    // Add some spans\n    trace.addTag('version', '1.0.0');\n    trace.log('Starting complex operation');\n\n    // Simulate child operations\n    const childTrace1 = trace.startSpan('cache-service', 'cache-lookup');\n    if (childTrace1) {\n      childTrace1.addTag('cache-key', 'demo-key');\n      await new Promise(resolve => setTimeout(resolve, 50));\n      childTrace1.log('Cache lookup completed');\n      childTrace1.end();\n    }\n\n    const childTrace2 = trace.startSpan('database-service', 'query-execution');\n    if (childTrace2) {\n      childTrace2.addTag('query', 'SELECT * FROM demos');\n      await new Promise(resolve => setTimeout(resolve, 100));\n      childTrace2.log('Query executed successfully');\n      childTrace2.end();\n    }\n\n    trace.log('Complex operation completed');\n    trace.end();\n\n    // Get trace statistics\n    const stats = tracing.getStatistics();\n    logger.info('üîç Tracing statistics:', {\n      totalTraces: stats.totalTraces,\n      activeTraces: stats.activeTraces,\n      completedTraces: stats.completedTraces,\n      avgDuration: `${stats.avgDuration.toFixed(2)}ms`,\n    });\n\n    // Export trace\n    const exportedTrace = tracing.exportTrace(trace.getTraceId());\n    if (exportedTrace) {\n      logger.info('üì§ Exported trace:', {\n        traceId: exportedTrace.traceId,\n        duration: exportedTrace.duration,\n        spans: (exportedTrace as any).spans.length,\n      });\n    }\n  }\n}\n\n/**\n * Display final summary\n */\nfunction displayFinalSummary(systemIntegration: EnhancedSystemIntegration): void {\n  logger.info('\\nüéØ ORCHESTRATION DEMO SUMMARY:');\n  logger.info('  ‚úÖ Orchestrated startup with dependency resolution');\n  logger.info('  ‚úÖ Type-safe service communication with circuit breakers');\n  logger.info('  ‚úÖ Real-time health monitoring with incident tracking');\n  logger.info('  ‚úÖ Performance profiling with bottleneck identification');\n  logger.info('  ‚úÖ Chaos engineering for resilience testing');\n  logger.info('  ‚úÖ Automatic optimization based on profiling data');\n  logger.info('  ‚úÖ Rolling restart with zero-downtime updates');\n  logger.info('  ‚úÖ Distributed tracing across service boundaries');\n  logger.info('\\nüöÄ The Advanced Service Orchestration system is fully operational!');\n}\n\n/**\n * Graceful shutdown for demo\n */\nasync function shutdownDemo(): Promise<void> {\n  logger.info('\\nüì§ Shutting down orchestration demo...');\n  \n  try {\n    const systemIntegration = EnhancedSystemIntegration.getInstance();\n    await systemIntegration.shutdown('demo-completed');\n    logger.info('‚úÖ Demo shutdown completed successfully');\n  } catch (error) {\n    logger.error('‚ùå Demo shutdown failed', { error });\n  }\n}\n\n// Handle graceful shutdown\nprocess.on('SIGINT', async () => {\n  logger.info('\\nüì§ Received SIGINT, shutting down gracefully...');\n  await shutdownDemo();\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  logger.info('\\nüì§ Received SIGTERM, shutting down gracefully...');\n  await shutdownDemo();\n  process.exit(0);\n});\n\n// Run the demo\nif (import.meta.main) {\n  runOrchestrationDemo()\n    .then(() => {\n      logger.info('\\nüéâ Orchestration demo completed successfully!');\n      logger.info('Press Ctrl+C to shutdown...');\n    })\n    .catch((error) => {\n      logger.error('‚ùå Orchestration demo failed', { error });\n      process.exit(1);\n    });\n}"